name: Version Bump

on:
  push:
    branches:
      - main

jobs:
  version:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Enable Corepack
        run: corepack enable

      - name: Install dependencies
        run: yarn install --immutable

      - name: Configure Git for tag creation
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create Release Pull Request or Create Tag
        id: changesets
        uses: changesets/action@v1
        with:
          version: yarn run version
          commit: "chore: version packages"
          title: "chore: version packages"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if version was actually bumped
        id: check_version_commit
        shell: bash
        run: |
          set -euo pipefail

          # Current version in HEAD
          NEW_VERSION="$(node -p "require('./package.json').version")"

          # Previous version from the previous commit (if it exists)
          if git rev-parse --verify HEAD~1 >/dev/null 2>&1; then
            OLD_VERSION="$(git show HEAD~1:package.json 2>/dev/null | node -p "JSON.parse(require('fs').readFileSync(0,'utf8')).version" || true)"
          else
            OLD_VERSION=""
          fi

          echo "Previous version: ${OLD_VERSION:-<none>}"
          echo "Current version:  ${NEW_VERSION}"

          if [[ -z "$OLD_VERSION" ]]; then
            echo "should_release=false" >> "$GITHUB_OUTPUT"
            echo "Can't determine previous version (first commit or missing file) - skipping release"
            exit 0
          fi

          if [[ "$NEW_VERSION" != "$OLD_VERSION" ]]; then
            echo "should_release=true" >> "$GITHUB_OUTPUT"
            echo "Version changed: $OLD_VERSION -> $NEW_VERSION"
          else
            echo "should_release=false" >> "$GITHUB_OUTPUT"
            echo "Version did not change - skipping release"
          fi

      - name: Create Git Tag
        if: steps.changesets.outputs.hasChangesets == 'false' && steps.check_version_commit.outputs.should_release == 'true'
        run: |
          # Get the current version from package.json
          VERSION=$(node -p "require('./package.json').version")
          TAG_NAME="v${VERSION}"
          
          # Check if tag already exists
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "Tag $TAG_NAME already exists, skipping..."
            exit 0
          fi
          
          # Create and push the tag
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
          git push origin "$TAG_NAME"
          
          echo "Tag $TAG_NAME created and pushed successfully"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate and Create GitHub Release
        if: steps.changesets.outputs.hasChangesets == 'false' && steps.check_version_commit.outputs.should_release == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const version = require('./package.json').version;
            const tagName = `v${version}`;
            
            // Check if release already exists
            try {
              await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tagName
              });
              console.log(`Release ${tagName} already exists, skipping...`);
              return;
            } catch (error) {
              if (error.status !== 404) throw error;
            }
            
            // Get previous tag
            const { data: tags } = await github.rest.repos.listTags({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 10,
            });
            
            let previousTagName = '';
            // Find the previous tag (skip current tag if it exists)
            for (const tag of tags) {
              if (tag.name !== tagName) {
                previousTagName = tag.name;
                break;
              }
            }
            
            console.log(`Generating release notes from ${previousTagName || 'start'} to ${tagName}`);
            
            // Get commits between tags
            let commits = [];
            try {
              const { data: comparison } = await github.rest.repos.compareCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                base: previousTagName || 'HEAD~50',
                head: 'main',
              });
              commits = comparison.commits;
            } catch (error) {
              console.log('Could not compare commits:', error.message);
            }
            
            // Get PRs for these commits
            const prMap = new Map();
            for (const commit of commits) {
              try {
                const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  commit_sha: commit.sha,
                });
                
                for (const pr of prs) {
                  if (pr.merged_at && !prMap.has(pr.number)) {
                    prMap.set(pr.number, pr);
                  }
                }
              } catch (error) {
                // Skip if we can't get PRs for this commit
              }
            }
            
            const prs = Array.from(prMap.values());
            console.log(`Found ${prs.length} merged PRs`);
            
            // Categorize PRs by labels
            const breaking = [];
            const features = [];
            const bugs = [];
            const improvements = [];
            const docs = [];
            const dependencies = [];
            const chores = [];
            const other = [];
            
            prs.forEach(pr => {
              const labels = pr.labels.map(l => l.name);
              const prLine = `- ${pr.title} (#${pr.number}) @${pr.user.login}`;
              
              if (labels.includes('breaking')) {
                breaking.push(prLine);
              } else if (labels.includes('type: feature')) {
                features.push(prLine);
              } else if (labels.includes('type: bug')) {
                bugs.push(prLine);
              } else if (labels.includes('type: improvement')) {
                improvements.push(prLine);
              } else if (labels.includes('type: docs')) {
                docs.push(prLine);
              } else if (labels.includes('dependencies')) {
                dependencies.push(prLine);
              } else if (labels.includes('type: chore')) {
                chores.push(prLine);
              } else {
                other.push(prLine);
              }
            });
            
            // Build release notes
            let releaseNotes = `## Release ${tagName}\n\n`;
            
            if (breaking.length > 0) {
              releaseNotes += `### Breaking Changes\n${breaking.join('\n')}\n\n`;
            }
            if (features.length > 0) {
              releaseNotes += `### New Features\n${features.join('\n')}\n\n`;
            }
            if (bugs.length > 0) {
              releaseNotes += `### Bug Fixes\n${bugs.join('\n')}\n\n`;
            }
            if (improvements.length > 0) {
              releaseNotes += `### Improvements\n${improvements.join('\n')}\n\n`;
            }
            if (docs.length > 0) {
              releaseNotes += `### Documentation\n${docs.join('\n')}\n\n`;
            }
            if (dependencies.length > 0) {
              releaseNotes += `### Dependencies\n${dependencies.join('\n')}\n\n`;
            }
            if (chores.length > 0) {
              releaseNotes += `### Chores\n${chores.join('\n')}\n\n`;
            }
            if (other.length > 0) {
              releaseNotes += `### Other Changes\n${other.join('\n')}\n\n`;
            }
            
            if (prs.length === 0) {
              releaseNotes += `No merged pull requests found for this release.\n\n`;
            }
            
            if (previousTagName) {
              releaseNotes += `\n---\n**Full Changelog**: https://github.com/${context.repo.owner}/${context.repo.repo}/compare/${previousTagName}...${tagName}`;
            }
            
            // Create GitHub Release
            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tagName,
              name: `Release ${tagName}`,
              body: releaseNotes,
              draft: false,
              prerelease: false,
              make_latest: 'true'
            });
            
            console.log(`Release ${tagName} created successfully!`);
            console.log(`Release URL: ${release.data.html_url}`);
